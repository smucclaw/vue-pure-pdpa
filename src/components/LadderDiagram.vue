<template>
<div id="ladderDiagram" style="font-size:1.5em;" ref="ladderHere" @ladderEvent="ladderEventHandler"></div>
<div id="debuggery">
  <h2>debug: AnyAll source</h2>
  <pre>{{ JSON.stringify(asCircuit,null,2) }}</pre>
</div>
</template>

<script setup>
  import { ref, computed, onMounted, onUpdated } from 'vue'
  import { useStore } from 'vuex'
import { BoolVar, AllQuantifier, AnyQuantifier, LadderDiagram } from 'ladder-diagram';

const props = defineProps({question: Object})

const store = useStore()

const asCircuit = computed(() => {
  // console.log(`LadderDiagram: computing asCircuit`)
  return q2circuit(store.getters.questions)
})

// when the user clicks on the form Yes/No/Don'tKnow, Vue natively
// handles that by updating the store and recomputing everything. But
// when the user clicks on a text node in the ladder-diagram, because the
// diagram isn't a proper Vue component but is HTML DOM generated by
// the LadderDiagram constructor, we have to do a bit of magic to toss
// events between the native HTML DOM onClick, and the Vue component
// event listener. And what does the Vue event listener do? It cycles
// the value of that particular element across Yes/No/Don'tKnow
// values, and writes the new value to the store as though the user
// had clicked in the form itself.
  
  // so, one way to do it, if we follow the QuestionRadio example, is to define an emitter to update.
  // but we're using Vuex, so let's try writing directly to the store, shall we?

function ladderEventHandler(e) {
  // console.log(`ladderEventHandler: handling event ${e}`);
  // console.log(e);
  // console.log(`ladderEventHandler: the current getMarkingField value of ${e.detail} is ${store.getters.getMarkingField(e.detail)}`);
  // console.log(store.getters.getMarkingField(e.detail))

  store.commit("updateMarkingField", {
    question: e.detail,
    answer: {
      source: "user",
      value: cycleUTF(store.getters.getMarkingField(e.detail))
    },
  })
  
}

function cycleUTF(currentState) {
  return (currentState == undefined       ? "true" :
          currentState.value == "true"    ? "false" :
          currentState.value == "false"   ? "unknown" :
          currentState.value == "unknown" ? "true" : "true")
}
  
// recursively transform a QoutJS object from the store.questions into a Circuit object from LadderDiagram.
function q2circuit(q) {
  if (q.andOr.tag == "Leaf") {
    let utf = (q.mark.value == "undefined" ? 'U' :
               q.mark.value == "true"      ? 'T' :
               q.mark.value == "false"     ? 'F' :
               null)
    return new BoolVar(q.andOr.contents, // [TODO] nl.en || contents
                       false, // [TODO] this should depend on SimplyNot
                       q.mark.source == "default" ? utf : null,
                       q.mark.source == "user"    ? utf : null,
                      )
  }

  return (new
          (q.andOr.tag == "All" ? AllQuantifier : AnyQuantifier)
          (q.andOr.children.map((c) => q2circuit(c))))
}


// mount the ladder diagram image into the template, using the ref to ladderHere
//
// https://vuejs.org/guide/essentials/computed.html#writable-computed says:
// don't make async requests or mutate the DOM inside a computed getter!
const ladderHere = ref()
const ld = computed(() => {
  // console.log(`in computed(ld): ladderHere.value = ${ladderHere.value}`);
  return (new LadderDiagram( asCircuit.value));
})
onMounted(() => {
  // console.log(`ladderHere.value = ${ladderHere.value}`)
  // console.log(`LadderDiagram: onMounted: appending LD element`);
  // ladderHere.value.appendChild(ld.value.dom_diagram);
  ld.value.attach(ladderHere.value);
})
// update the ladder diagram every time the store updates
onUpdated(() => {
  // console.log(`LadderDiagram: onUpdated: resetting LD element`);
  ladderHere.value.removeChild(ladderHere.value.firstElementChild);
  // ladderHere.value.appendChild(ld.value.dom_diagram);
  // ld.value.detach();
  ld.value.attach(ladderHere.value);
})

</script>

<style>
@import '~ladder-diagram/css/ladder.css';
</style>

<!--
  
// [TODO] this will come from the store
const sampleData = ref(
  new AllQuantifier([
    new AnyQuantifier([
      new BoolVar(    "Left  Null",    false, null, null  ),
      new BoolVar(    "Left  Nothing", false, 'U',  null  ),
      new BoolVar(    "Left  True",    false, 'T',  null  ),
      new BoolVar(    "Left  False",   false, 'F',  null  ),
      new BoolVar("Not Left  Null",    true,  null, null  ),
      new BoolVar("Not Left  Nothing", true,  'U',  null  ),
      new BoolVar("Not Left  False",   true,  'F',  null  ),
      new BoolVar("Not Left  True",    true,  'T',  null  ),
    ]),
    new AnyQuantifier([
      new BoolVar(    "Right Null",    false, null, null  ),
      new BoolVar(    "Right Nothing", false, null, 'U'   ),
      new BoolVar(    "Right True",    false, null, 'T'   ),
      new BoolVar(    "Right False",   false, null, 'F'   ),
      new BoolVar("Not Right Null",    true,  null, null  ),
      new BoolVar("Not Right Nothing", true,  null, 'U'   ),
      new BoolVar("Not Right False",   true,  null, 'F'   ),
      new BoolVar("Not Right True",    true,  null, 'T'   ),
    ])
  ])
)

-->
  
